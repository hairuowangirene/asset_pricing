---
title: "QF600 Asset Pricing Homework 4"
author: "Wang Hairuo"
date: '2022-10-10'
output:
  pdf_document:
    template: report.tex
    toc: yes
    toc_depth: 2
lang: en
subtitle: Efficient Frontier Revisited
titlepage: yes
titlepage-color: 6C3082
titlepage-text-color: FFFFFF
titlepage-rule-color: FFFFFF
titlepage-rule-height: 2
---

\newpage

# Part 1: Minimum-Track-Error Frontier

**Let the market return be the target return.**
```{r, include = FALSE}
library(tidyverse)
library(ggplot2)
library(knitr)
library(readxl)
```

```{r, include = FALSE}
industry_df = read_excel("Industry_Portfolios.xlsx")
industry_df = industry_df %>% 
  select(!Date)
market_df = read_excel("Market_Portfolio.xlsx")
market_df = market_df %>% 
  select(!Date)
```


## Question 1: Estimate the Expected Deviation from Market Return for the Ten Industry Portfolios. Also Estimate the Covariance Matrix of Return Deviation for Ten Industry Portfolios. 

```{r, echo = FALSE}
# compute the return deviation
new_industry_df = industry_df - market_df$Market
# expected return deviation
mean_return = colMeans(new_industry_df)
# create a table to show the expected return deviation
kable(mean_return, 
      col.names = "Expected Return Deviation", 
      caption = "Expected Deviation from Market Return for Ten Industry Portfolios", 
      digits = 4)
```

According to **Table 1**, which shows the expected return deviation from market return for ten industry portfolios. 

\newpage

```{r, echo = FALSE}
# covariance matrix for return deviation
cov_matrix = cov(new_industry_df)
# create a table to show the covariance matrix
kable(cov_matrix, 
      caption = "The Covariance Matrix of Return Deviation for Ten Industry Portfolios",  
      digits = 3)
```

**Table 2** shows the covariance matrix of return deviation for ten industry portfolios. 

\newpage

## Question 2: Plot the minimum-tracking-error frontier generated by the ten industry portfolios, with expected (monthly) return deviation on the vertical axis and (monthly) tracking error on the horizontal axis. This plot should cover the range from 0% to 0.1% on the vertical axis, in increments of 0.005% (or less).

```{r, include = FALSE}
# compute the return deviation
new_industry_df = industry_df - market_df$Market
# expected return deviation
mean_return = colMeans(new_industry_df)
# the covariance matrix for return deviation
cov_matrix = cov(new_industry_df)
# the inverse covariance matrix for return deviation
inverse_cov_matrix = solve(cov_matrix)
# the number of industry portfolios
n = ncol(new_industry_df)
# unit vector
e_vector = as.vector(rep(x = 1, times = n))
```

```{r, include = FALSE}
# alpha 
alpha = t(mean_return) %*% inverse_cov_matrix %*% e_vector
# zeta 
zeta = t(mean_return) %*% inverse_cov_matrix %*% mean_return
# delta
delta = t(e_vector) %*% inverse_cov_matrix %*% e_vector
```

```{r, include = FALSE}
# set the given expected return deviation
return_p = seq(0, 0.1, 0.0001)
# compute the mean return for global minimum-tracking-error portfolio
return_mv = alpha / delta
# compute the tracking error with given expected return deviation
sigma_p = sqrt((1 / as.numeric(delta)) + (as.numeric(delta) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)) * (return_p - as.numeric(return_mv)) ^ 2)
# record the expected return deviation and tracking error into data frame
plot_df = data.frame(return_p, sigma_p)
```

```{r, echo = FALSE, fig.cap="The Minimum-Tracking-Error Frontier"}
# plot the minimum-tracking-error frontier
plot_df %>% 
  # select tracking error as x-axis and expected return deviation as y-axis
  ggplot(aes(x = sigma_p, y = return_p)) + 
  # plot the top half of frontier as solid line
  geom_path(data = subset(plot_df, return_p >= as.numeric(return_mv)), linetype = 1, color = '#F8B195')+
  # plot the bottom half of frontier as dotted line
  geom_path(data = subset(plot_df, return_p < as.numeric(return_mv)), linetype = 2, color = '#6C5B7B')+
  # use the minimalstic theme for the plot
  theme_minimal() + 
  # add x label
  xlab("Tracking Error") + 
  # add y label
  ylab("Expected Return Deviation")
```

**Figure 1** shows the minimum-tracking-error frontier which generated by ten industry portfolios. 

## Question 2: Also plot the line starting from the origin that is tangent to the upper half of the minimum-tracking-error frontier, and calculate the information ratio and portfolio weights for the "tangency" portfolio.

### Plot of Minimum-Tracking-Error Frontier and Tangent Line to Upper Frontier

```{r, include = FALSE}
# compute the tracking error with risk-free rate of zero
sigma_p2 = sqrt(((return_p ** 2) / as.numeric(zeta)))
# add the tracking error for tangent line into the data frame
plot_df2 = data.frame(return_p, sigma_p, sigma_p2)
```

```{r, echo = FALSE, fig.cap="Minimum-Tracking-Error Frontier and Tangent Line for Upper Frontier"}
# plot the minimum tracking error frontier and the tangent line for the frontier
plot_df2 %>% 
  # use tracking error as x-axis and return deviation as y-axis
  ggplot(aes(x = sigma_p, y = return_p)) + 
  # plot the top half of frontier with solid line
  geom_path(data = subset(plot_df2, return_p >= as.numeric(return_mv)), linetype = 1, color = '#F8B195') + 
  # plot the bottom half of frontier with dotted line
  geom_path(data = subset(plot_df2, return_p < as.numeric(return_mv)), linetype = 2, color = '#6C5B7B')+
  # plot the tangent line to the frontier
  geom_path(aes(x = sigma_p2, y = return_p), color = "light pink") + 
  # use the minimalistic theme to the plot
  theme_minimal() + 
  # add x label
  xlab("Tracking Error") + 
  # add y label
  ylab("Expected Return Deviation")
```

**Figure 2** shows the minimum-tracking-error frontier and the tangent line to the frontier. There is a tangent point on the plot, and that represents the tangency portfolio. 

\newpage

### Information Ratio and Portfolio Weights for "Tangency" Portfolio

$$
I_i = \frac{E(R_{i} - R_m)}{\sqrt{Var(R_{i} - R_m)}}
$$

This is the formula for the Information Ratio, which represent the expected deviation from market return, per unit of tracking error. 

```{r, include = FALSE}
# Information Ratio
# return deviation for tangency portfolio
return_tg = - as.numeric(zeta) / - as.numeric(alpha)
# tracking error for tangency portfolio
sigma_tg = - ((as.numeric(zeta)) ^ 0.5) / (as.numeric(delta) * (-return_mv))
# compute the information ratio
information_ratio = return_tg / sigma_tg
```

As we generated the scalar $\alpha$, $\zeta$ and $\delta$ of Lagrange multipliers by the deviation of industry portfolio return from market rate. Therefore, we could compute the expected deviation of tangency portfolio by the scalar of $\zeta$ and $\alpha$ and with following formula, 

$$E(R_{tg} - R_m) = \frac{\zeta}{\alpha}$$ 

Moreover, the expected deviation for tangency portfolio is `r round(return_tg, 4)`

As well, we could compute the tracking error for tangency portfolio by the following formula and consider risk-free rate as 0, 

$$
\sqrt{Var(R_{tg} - R_m)} = - \frac{\zeta - 2\alpha R_f + \delta R_f ^ 2}{\delta(R_f - R_{mv})}
$$

As we consider risk-free rate as 0, and the tracking error is:

$$
\sqrt{Var(R_{tg} - R_m)} = - \frac{\zeta}{\delta (-R_{mv})}
$$

Therefore, the tracking error for tangency portfolio is `r round(sigma_tg, 4)`

Overall, we could compute the information ratio by above formula and **the information ratio for the tangency portfolio in this case is `r round(information_ratio[1, 1], 4)`**

\newpage

```{r, echo = FALSE}
a = ((as.numeric(zeta) * inverse_cov_matrix %*% e_vector) - (as.numeric(alpha) * inverse_cov_matrix %*% mean_return)) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)

b = ((as.numeric(delta) * inverse_cov_matrix %*% mean_return) - (as.numeric(alpha) * inverse_cov_matrix %*% e_vector)) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)

tangency_weight = a + b * return_tg
kable(tangency_weight, 
      col.names = "Portfolio Weights", 
      caption = "The Portfolio Weights for the Tangency Portfolio")
```

According to **Table 3**, which is the each industry portfolio weights for the tangency portfolio. The positive portfolio weight represents the normal investment or long position. 

\newpage

# Part 2: Minimum-Variance Frontier

**Use the monthly returns of the ten industry portfolios to generate the minimum-variance frontier without short sales, using Monte Carlo simulation. Portfolio weights will be limited to the range [0, 1]. Randomly draw each element of w, the vector of portfolio weights, from the (standard) uniform distribution in the range [0, 1]. Divide w by the sum of the portfolio weights, to ensure that the portfolio weights sum to one. Use the normalized w to calculate the mean return and standard deviation of return for the simulated portfolio. Repeat this process until you have (at least) 10^5 data points.**

## Question 1: Plot the data points with mean return on the vertical axis and standard deviation of return on the horizontal axis.

```{r, include = FALSE}
# set seed in order to get same random weight
set.seed(600)
```

```{r, include = FALSE}
# mean return for industry portfolios
mean_return2 = colMeans(industry_df)
# covariance matrix for industry portfolios
cov_matrix2 = cov(industry_df)
```

```{r, include = FALSE}
# number of industry portfolio that we simulate
number_asset = ncol(industry_df)
# number of simulated data points
number_weights = 10^5

# create list and data frame to record the simulated mean return and standard deviation of return  
weight_df = list()
sim_return_df = data.frame()
sim_sigma_df = data.frame()

# first set for simulating weights and compute the simulated mean return and sd of return
for (i in 1:number_weights / 2){
  # randomly draw weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # normalized the weights
  weights = weights / sum(weights)
  returns = mean_return2 %*% weights
  sigma = sqrt(t(weights) %*% cov_matrix2 %*% weights)
  weight_df[i] = list(weights)
  sim_return_df[i, 1] = as.numeric(returns)
  sim_sigma_df[i, 1] = as.numeric(sigma)
}
```

```{r, include = FALSE}
# second set for simulating weights and compute the simulated mean return and sd of return
for (i in (number_weights / 2 + 1):number_weights){
  # randomly draw weights from uniform distribution
  weights = runif(number_asset, 0, 1)
  # normalized the weights
  weights = weights / sum(weights)
  returns = mean_return2 %*% weights
  sigma = sqrt(t(weights) %*% cov_matrix2 %*% weights)
  weight_df[i] = list(weights)
  sim_return_df[i, 1] = as.numeric(returns)
  sim_sigma_df[i, 1] = as.numeric(sigma)
}
```

```{r, include = FALSE}
# put simulated mean return and standard deviation of mean into data frame
plot_df3 = data.frame(sim_return_df, sim_sigma_df)
# change column name for the data frame
colnames(plot_df3) = c("return", "sd")
```

```{r, echo = FALSE, fig.cap="Minimum-Variance Frontier with Simulated Data Points"}
# plot the minimum-variance frontier with simulated data points
plot_df3 %>% 
  # select standard deviation of return on x-axis and mean return on y-axis
  ggplot(aes(x = sd, y = return)) + 
  # set the color the points
  geom_point(aes(color = '#C06C84')) + 
  # use minimalistic theme for the plots
  theme_minimal() + 
  # add x label
  xlab("Standard Deviation of Return") + 
  # add y label
  ylab("Mean Return")+
  # remove the non-informative legend
  theme(legend.position = 'None') 
```

**Figure 3**  shows the minimum-variance frontier based on the simulated weight from standard uniform distribution. 

**Repeat this entire process by simulating 1/w using the standard uniform distribution, then take the reciprocal of the random draw from the standard uniform distribution as the portfolio weight.**

## Question 2: Plot the new data points with mean return on the vertical axis and standard deviation of return on the horizontal axis.

```{r, include = FALSE}
# number of industry portfolios that we simulate
number_asset = ncol(industry_df)
# number of data point that we are going to simulate
number_weights = 10^5

# create list and data frame to save the simulated mean return and standard deviation of return
weight_df2 = list()
sim_return_df2 = data.frame()
sim_sigma_df2 = data.frame()

# first set for simulating weights and compute the simulated mean return and standard deviation of return
for (i in 1:number_weights / 2){
  # randomly draw 1/weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # compute the reciprocal of 1/weights
  weights = 1 / weights
  # normalized the weights
  real_weight = weights / sum(weights)
  returns = mean_return2 %*% real_weight
  sigma = sqrt(t(real_weight) %*% cov_matrix2 %*% real_weight)
  weight_df2[i] = list(real_weight)
  sim_return_df2[i, 1] = as.numeric(returns)
  sim_sigma_df2[i, 1] = as.numeric(sigma)
}
```

```{r, include = FALSE}
# second set for simulating weights and compute the simulated mean return and standard deviation of return
for (i in (number_weights / 2 + 1): number_weights){
  # randomly draw 1/weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # compute the reciprocal of 1/weights
  weights = 1 / weights
  # normalized the weights
  real_weight = weights / sum(weights)
  returns = mean_return2 %*% real_weight
  sigma = sqrt(t(real_weight) %*% cov_matrix2 %*% real_weight)
  weight_df2[i] = list(real_weight)
  sim_return_df2[i, 1] = as.numeric(returns)
  sim_sigma_df2[i, 1] = as.numeric(sigma)
}
```

```{r, include = FALSE}
# put simulated mean return and standard deviation of mean into data frame
plot_df4 = data.frame(sim_return_df2, sim_sigma_df2)
# change column names
colnames(plot_df4) = c("return", "sd")
```

```{r, echo = FALSE, fig.cap = "Minimum-Variance Frontier with Simulated Data Points"}
# plot the minimum-variance frontier with simulated data points
plot_df4 %>% 
  # select standard deviation of return as x-axis and mean return as y-axis
  ggplot(aes(x = sd, y = return)) + 
  # set the color for data points
  geom_point(aes(color = '#F8B195')) + 
  # use minimalistic theme
  theme_minimal() + 
  # add x label
  xlab("Standard Deviation of Return") + 
  # add y label
  ylab("Mean Return") +
  # remove the non-informative legend
  theme(legend.position = 'None') 
```

**Figure 4** shows the minimum-variance frontier based on the simulated reciprocal of weight from standard uniform distribution. 

# Appendix

## Set up Code

```{r, results = 'hide'}
library(tidyverse)
library(ggplot2)
library(knitr)
library(readxl)
```

```{r, results = 'hide'}
industry_df = read_excel("Industry_Portfolios.xlsx")
industry_df = industry_df %>% 
  select(!Date)
market_df = read_excel("Market_Portfolio.xlsx")
market_df = market_df %>% 
  select(!Date)
```

## `Part 1 - Question 1`

```{r, results='hide'}
# compute the return deviation
new_industry_df = industry_df - market_df$Market
# expected return deviation
mean_return = colMeans(new_industry_df)
# create a table to show the expected return deviation
kable(mean_return, 
      col.names = "Expected Return Deviation", 
      caption = "Expected Deviation from Market Return for Ten Industry Portfolios", 
      digits = 4)
```

```{r, results='hide'}
# covariance matrix for return deviation
cov_matrix = cov(new_industry_df)
# create a table to show the covariance matrix
kable(cov_matrix, 
      caption = "The Covariance Matrix of Return Deviation for Ten Industry Portfolios", 
      digits = 3)
```

## `Part 1 - Question 2`

```{r, results='hide'}
# compute the return deviation
new_industry_df = industry_df - market_df$Market
# expected return deviation
mean_return = colMeans(new_industry_df)
# the covariance matrix for return deviation
cov_matrix = cov(new_industry_df)
# the inverse covariance matrix for return deviation
inverse_cov_matrix = solve(cov_matrix)
# the number of industry portfolios
n = ncol(new_industry_df)
# unit vector
e_vector = as.vector(rep(x = 1, times = n))
```

```{r, results = 'hide'}
# alpha 
alpha = t(mean_return) %*% inverse_cov_matrix %*% e_vector
# zeta 
zeta = t(mean_return) %*% inverse_cov_matrix %*% mean_return
# delta
delta = t(e_vector) %*% inverse_cov_matrix %*% e_vector
```

```{r, results = 'hide'}
# set the given expected return deviation
return_p = seq(0, 0.1, 0.0001)
# compute the mean return for global minimum-tracking-error portfolio
return_mv = alpha / delta
# compute the tracking error with given expected return deviation
sigma_p = sqrt((1 / as.numeric(delta)) + (as.numeric(delta) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)) * (return_p - as.numeric(return_mv)) ^ 2)
# record the expected return deviation and tracking error into data frame
plot_df = data.frame(return_p, sigma_p)
```

```{r, fig.show='hide'}
# plot the minimum-tracking-error frontier
plot_df %>% 
  # select tracking error as x-axis and expected return deviation as y-axis
  ggplot(aes(x = sigma_p, y = return_p)) + 
  # plot the top half of frontier as solid line
  geom_path(data = subset(plot_df, return_p >= as.numeric(return_mv)), linetype = 1, color = '#F8B195')+
  # plot the bottom half of frontier as dotted line
  geom_path(data = subset(plot_df, return_p < as.numeric(return_mv)), linetype = 2, color = '#6C5B7B')+
  # use the minimalstic theme for the plot
  theme_minimal() + 
  # add x label
  xlab("Tracking Error") + 
  # add y label
  ylab("Expected Return Deviation")
```

## `Part 1 - Question 3`

```{r, results='hide'}
# compute the tracking error with risk-free rate of zero
sigma_p2 = sqrt(((return_p ** 2) / as.numeric(zeta)))
# add the tracking error for tangent line into the data frame
plot_df2 = data.frame(return_p, sigma_p, sigma_p2)
```

```{r, fig.show='hide'}
# plot the minimum tracking error frontier and the tangent line for the frontier
plot_df2 %>% 
  # use tracking error as x-axis and return deviation as y-axis
  ggplot(aes(x = sigma_p, y = return_p)) + 
  # plot the top half of frontier with solid line
  geom_path(data = subset(plot_df2, return_p >= as.numeric(return_mv)), linetype = 1, color = '#F8B195') + 
  # plot the bottom half of frontier with dotted line
  geom_path(data = subset(plot_df2, return_p < as.numeric(return_mv)), linetype = 2, color = '#6C5B7B')+
  # plot the tangent line to the frontier
  geom_path(aes(x = sigma_p2, y = return_p), color = "light pink") + 
  # use the minimalistic theme to the plot
  theme_minimal() + 
  # add x label
  xlab("Tracking Error") + 
  # add y label
  ylab("Expected Return Deviation")
```

```{r, results = 'hide'}
# Information Ratio
# return deviation for tangency portfolio
return_tg = - as.numeric(zeta) / - as.numeric(alpha)
# tracking error for tangency portfolio
sigma_tg = - ((as.numeric(zeta)) ^ 0.5) / (as.numeric(delta) * (-return_mv))
# compute the information ratio
information_ratio = return_tg / sigma_tg
```

```{r, results = 'hide'}
a = ((as.numeric(zeta) * inverse_cov_matrix %*% e_vector) - (as.numeric(alpha) * inverse_cov_matrix %*% mean_return)) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)

b = ((as.numeric(delta) * inverse_cov_matrix %*% mean_return) - (as.numeric(alpha) * inverse_cov_matrix %*% e_vector)) / (as.numeric(zeta) * as.numeric(delta) - as.numeric(alpha) ^ 2)

tangency_weight = a + b * return_tg
kable(tangency_weight, 
      col.names = "Portfolio Weights", 
      caption = "The Portfolio Weights for the Tangency Portfolio")
```

## `Part 2 - Question 1`

```{r, results='hide'}
# set seed in order to get same random weight
set.seed(600)
```

```{r, results='hide'}
# mean return for industry portfolios
mean_return2 = colMeans(industry_df)
# covariance matrix for industry portfolios
cov_matrix2 = cov(industry_df)
```

```{r, results='hide'}
# number of industry portfolio that we simulate
number_asset = ncol(industry_df)
# number of simulated data points
number_weights = 10^5

# create list and data frame to record the simulated mean return and standard deviation of return  
weight_df = list()
sim_return_df = data.frame()
sim_sigma_df = data.frame()

# first set for simulating weights and compute the simulated mean return and sd of return
for (i in 1:number_weights / 2){
  # randomly draw weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # normalized the weights
  weights = weights / sum(weights)
  returns = mean_return2 %*% weights
  sigma = sqrt(t(weights) %*% cov_matrix2 %*% weights)
  weight_df[i] = list(weights)
  sim_return_df[i, 1] = as.numeric(returns)
  sim_sigma_df[i, 1] = as.numeric(sigma)
}
```

```{r, results='hide'}
# second set for simulating weights and compute the simulated mean return and sd of return
for (i in (number_weights / 2 + 1):number_weights){
  # randomly draw weights from uniform distribution
  weights = runif(number_asset, 0, 1)
  # normalized the weights
  weights = weights / sum(weights)
  returns = mean_return2 %*% weights
  sigma = sqrt(t(weights) %*% cov_matrix2 %*% weights)
  weight_df[i] = list(weights)
  sim_return_df[i, 1] = as.numeric(returns)
  sim_sigma_df[i, 1] = as.numeric(sigma)
}
```

```{r, results='hide'}
# put simulated mean return and standard deviation of mean into data frame
plot_df3 = data.frame(sim_return_df, sim_sigma_df)
# change column name for the data frame
colnames(plot_df3) = c("return", "sd")
```

```{r, fig.show='hide'}
# plot the minimum-variance frontier with simulated data points
plot_df3 %>% 
  # select standard deviation of return on x-axis and mean return on y-axis
  ggplot(aes(x = sd, y = return)) + 
  # set the color the points
  geom_point(aes(color = '#C06C84')) + 
  # use minimalistic theme for the plots
  theme_minimal() + 
  # add x label
  xlab("Standard Deviation of Return") + 
  # add y label
  ylab("Mean Return")+
  # remove the non-informative legend
  theme(legend.position = 'None') 
```

## `Part 2 - Question 2`

```{r, results='hide'}
# number of industry portfolios that we simulate
number_asset = ncol(industry_df)
# number of data point that we are going to simulate
number_weights = 10^5

# create list and data frame to save the simulated mean return and standard deviation of return
weight_df2 = list()
sim_return_df2 = data.frame()
sim_sigma_df2 = data.frame()

# first set for simulating weights and compute the simulated mean return and standard deviation of return
for (i in 1:number_weights / 2){
  # randomly draw 1/weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # compute the reciprocal of 1/weights
  weights = 1 / weights
  # normalized the weights
  real_weight = weights / sum(weights)
  returns = mean_return2 %*% real_weight
  sigma = sqrt(t(real_weight) %*% cov_matrix2 %*% real_weight)
  weight_df2[i] = list(real_weight)
  sim_return_df2[i, 1] = as.numeric(returns)
  sim_sigma_df2[i, 1] = as.numeric(sigma)
}
```

```{r, results='hide'}
# second set for simulating weights and compute the simulated mean return and standard deviation of return
for (i in (number_weights / 2 + 1): number_weights){
  # randomly draw 1/weight from uniform distribution
  weights = runif(number_asset, 0, 1)
  # compute the reciprocal of 1/weights
  weights = 1 / weights
  # normalized the weights
  real_weight = weights / sum(weights)
  returns = mean_return2 %*% real_weight
  sigma = sqrt(t(real_weight) %*% cov_matrix2 %*% real_weight)
  weight_df2[i] = list(real_weight)
  sim_return_df2[i, 1] = as.numeric(returns)
  sim_sigma_df2[i, 1] = as.numeric(sigma)
}
```

```{r, results = 'hide'}
# put simulated mean return and standard deviation of mean into data frame
plot_df4 = data.frame(sim_return_df2, sim_sigma_df2)
# change column names
colnames(plot_df4) = c("return", "sd")
```

```{r, fig.show = 'hide'}
# plot the minimum-variance frontier with simulated data points
plot_df4 %>% 
  # select standard deviation of return as x-axis and mean return as y-axis
  ggplot(aes(x = sd, y = return)) + 
  # set the color for data points
  geom_point(aes(color = '#F8B195')) + 
  # use minimalistic theme
  theme_minimal() + 
  # add x label
  xlab("Standard Deviation of Return") + 
  # add y label
  ylab("Mean Return") +
  # remove the non-informative legend
  theme(legend.position = 'None') 
```